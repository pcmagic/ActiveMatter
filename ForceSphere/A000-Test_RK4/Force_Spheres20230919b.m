%=====================================================================================================================================================================
%%%%% 通过 Multipole Moment Method 方法求阻力矩阵！！！
%%%%% 边界条件：周期性边界条件！！！
%%%%% 模型：2D球体的集体行为！！！
%%%%% Peclet number: Pe=V0/(2a*DR)=V0*(4*pi*mu*a^2)/(kT)=5e-7*V0/(kT)
%%%%% 噪声：f = kT/a；f = 0，1，5，8，10，20，50，100
%%%%% xy平面
%=====================================================================================================================================================================
clear; clf; clc;
%format long
%=====================================================================================================================================================================
fid1 = fopen('Configuration.mat','wt');
fprintf(fid1,'Dimensionless Time & i & X & Y:\n');                         %构象
fid2 = fopen('Material_Frame.mat','wt');
fprintf(fid2,'Dimensionless Time & i & D3x & D3y:\n');                     %Material Frame
fid3 = fopen('Translation_Velocity.mat','wt');
fprintf(fid3,'Dimensionless Time & i & UX & UY:\n');                       %平移速度
fid4 = fopen('Rotation_Velocity.mat','wt');
fprintf(fid4,'Dimensionless Time & i & WZ:\n');                            %旋转速度
%%
%vidObj1 = VideoWriter('Configuration.avi');
%vidObj1.Quality = 100;                                                     %Quality:视频质量，指定为 [0,100] 范围内的整数。数字越大，视频质量越高，文件越大。质量数越小，则视频质量越低且文件大小越小。
%vidObj1.FrameRate = 30;                                                    %FrameRate:视频的播放速率（每秒帧数），指定为正数。调用 open 之后，无法更改 FrameRate 值。
%open(vidObj1);
%% 
%=====================================================================================================================================================================
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%% 计算无障碍球时细菌的初始三个拉伸长度、固有曲率、固有扰率和扭曲力矩的单位方向矢量！！！！！
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%=====================================================================================================================================================================
%% 主体部分的计算
kT1 = 4.1419470e-6;                                                        %室温(300K)时的热涨落的能量(g um2/s2)
kT2 = 5.5226020e-6;                                                        %400K时的热涨落的能量(g um2/s2)
kT = 300*1.380649e-8;                                                      %300K时的热涨落的能量(g um2/s2)
mu = 1.0e-6;                                                               %Fluid viscosity(血浆的粘度)(g/um/s)
frac = 1/(pi*mu);                                                          %前置系数
a = 1.0;                                                                   %所有球体的半径(这里为了计算方便取1)
dt0 = 6*pi*mu*a^3/kT;                                                      %时间单位
%% 
%% 数据处理参数
sdis = 1.0e-4;                                                             %最小表面间距 
dt = 5.00e-5*dt0;                                                          %时间步长 
time_h = 4*dt;                                                             %龙格库塔法时间步长 
For0 = 1.000;                                                              %白噪声的力
Tor0 = 1.000;                                                              %白噪声的力矩
For = 0.1000;                                                              %给定活性粒子的推进力(以kT/a为力的单位)(f：0，1，5，8，10，20，50，100)
Tor = 0.000*kT;                                                            %给定活性粒子的力矩(以kT为力矩的单位)
N_dat = 1;                                                            %数据输出（4的倍数）
N_fig = 1;                                                            %画图（4的倍数）
N_save = 1;                                                           %保存图片（N_fig的倍数）
[XSC,YSC,ZSC] = sphere(50);                                                %画球体
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% 生成随机球体
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
length = 3.00;                                                             % 图像长
width = 3.00;                                                              % 图像宽
NS = 4;
radii(1:NS) = a;
X0(1,:) = [2.9,2.9,0];
X0(2,:) = [0.1,2.9,0];
X0(3,:) = [0.1,0.1,0];
X0(4,:) = [2.9,0.1,0];
X = X0;
D3 = zeros(NS,3);                                                          % z 方向(球心处)
for i = 1:NS
    D3(i,:) = [1,0,0];
end  
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% 主体程序：模拟体系的动力学过程
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
tempX0 = X;                                                                %X0(实际位置)
tempD30 = D3;                                                              %D30(实际方向)
%================================================================================================================================================================================================================================
% 本部分模拟细菌、障碍球体系的动力学过程！！！！！
%================================================================================================================================================================================================================================
erro = 0;         N_erro = 0;                                              %误差下限、误差连续小于下限的次数(初始设置为0)
times = 0;                                                                 %时间
U = zeros(NS,3);     N_steps = 17;                                   %平移速度、循环次数上限
Sds = zeros(NS,2);                                                         %粒子的位移
for kkk = 1:N_steps  
%% 新的修正坐标
for i = 1:NS
    X(i,1) = mod(X(i,1),length);
    X(i,2) = mod(X(i,2),width);
end      
%% 
%=====================================================================================================================================================================
%通过 Multipole Moment Method 方法求阻力矩阵,各个球体不能重叠!!!
%=====================================================================================================================================================================
drx = zeros(NS,NS);     dry = zeros(NS,NS);     drz = zeros(NS,NS);     ddr = zeros(NS,NS);
ee = zeros(NS,NS,2);    delt = eye(2); 
for i = 1:NS
    for j = i+1:NS
        if (X(i,1) - X(j,1)) < - length/2
            drx(i,j) = (X(i,1) + length) - X(j,1);                         %球 j 到球 i 的矢量  
            drx(j,i) = -drx(i,j);                                          %球 i 到球 j 的矢量 
        elseif (X(i,1) - X(j,1)) > length/2
            drx(i,j) = (X(i,1) - length) - X(j,1);                         %球 j 到球 i 的矢量  
            drx(j,i) = -drx(i,j);                                          %球 i 到球 j 的矢量  
        else
            drx(i,j) = X(i,1) - X(j,1);                                    %球 j 到球 i 的矢量 
            drx(j,i) = -drx(i,j);                                          %球 i 到球 j 的矢量
        end

        if (X(i,2) - X(j,2)) < - width/2
            dry(i,j) = (X(i,2) + width) - X(j,2);                          %球 j 到球 i 的矢量  
            dry(j,i) = -dry(i,j);                                          %球 i 到球 j 的矢量 
        elseif (X(i,2) - X(j,2)) > width/2
            dry(i,j) = (X(i,2) - width) - X(j,2);                          %球 j 到球 i 的矢量  
            dry(j,i) = -dry(i,j);                                          %球 i 到球 j 的矢量  
        else
            dry(i,j) = X(i,2) - X(j,2);                                    %球 j 到球 i 的矢量 
            dry(j,i) = -dry(i,j);                                          %球 i 到球 j 的矢量
        end        
        
        ddr(i,j) = sqrt(drx(i,j)^2+dry(i,j)^2);    ddr(j,i) = ddr(i,j);
        ee(i,j,1) = drx(j,i)/ddr(i,j);             ee(j,i,1) = -ee(i,j,1); %注意：前一个编号到后一个编号的单位矢量！！！
        ee(i,j,2) = dry(j,i)/ddr(i,j);             ee(j,i,2) = -ee(i,j,2); %注意：这里的单位矢量定义按Jeffrey文献的定义，正好反过来！！！
    end
end

epsi = zeros(NS,NS,1,2);
for i = 1:NS
    for j = 1:NS
        if j == i
            continue
        end        
        epsi(i,j,1,1) = ee(i,j,2);                                             
        epsi(i,j,1,2) = -ee(i,j,1);
    end
end

rss = zeros(NS,NS);                                                        %文献中的 s=2r/(a1+a2)：s=2 时，两球接触
xi = zeros(NS,NS);                                                         %文献中的 xi=s-2
for i = 1:NS
    for j = 1:NS  
        if j == i
            continue
        end        
        rss(i,j) = 2*ddr(i,j)/(radii(i)+radii(j));
        rss(i,j) = max(rss(i,j),2.0+sdis);                                 %防止粒子重叠
        xi(i,j) = rss(i,j) - 2.0;
    end
end      
%% 阻力矩阵和迁移率矩阵
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% 构造阻力矩阵部分：R_{lubrication}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
XA11 = zeros(NS,NS);      YA11 = zeros(NS,NS);
YB11 = zeros(NS,NS);
XC11 = zeros(NS,NS);      YC11 = zeros(NS,NS);

XA = zeros(NS,NS);        YA = zeros(NS,NS);
YB = zeros(NS,NS);
XC = zeros(NS,NS);        YC = zeros(NS,NS);

for i = 1:NS
    for j = 1:NS
        if j == i
            continue
        end            
        if xi(i,j) <= 1.0
            XA11(i,j) = 0.25/xi(i,j) - 0.25;                               %在模拟中这项才能保证球体重叠不多
            YA11(i,j) = -1/6*log(xi(i,j));
            YB11(i,j) = 0.25*log(xi(i,j));
            YC11(i,j) = -0.2*log(xi(i,j));                                 %阻力矩阵的对角元

            XA(i,j) = -0.25/xi(i,j) + 0.25;                                %在模拟中这项才能保证球体重叠不多
            YA(i,j) = 1/6*log(xi(i,j));                                                                                         
            YB(i,j) = -0.25*log(xi(i,j));
            YC(i,j) = -0.05*log(xi(i,j));                                  %阻力矩阵的非对角元
        end
    end
end                                                                        %为了连续性，需要保证链接点处值为 0
%% 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%远场时，迁移率矩阵各个分量（大迁移率矩阵，即 RPY 张量）
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
XaF = zeros(NS,NS);       YaF = zeros(NS,NS);
YbF = zeros(NS,NS);
XcF = zeros(NS,NS);       YcF = zeros(NS,NS);
for i = 1:NS
    for j = 1:NS
        if j == i
            continue
        end
        XaF(i,j) = 1.5/rss(i,j) - rss(i,j)^(-3);
        YaF(i,j) = 0.75/rss(i,j) + 0.5*rss(i,j)^(-3);
        YbF(i,j) = -0.5*rss(i,j)^(-2);
        XcF(i,j) = rss(i,j)^(-3);
        YcF(i,j) = -0.5*rss(i,j)^(-3); 
    end
end
%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% 构造阻力矩阵部分:(M_inf)^(-1)，包括量纲化
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
MTT = zeros(2*NS,2*NS);    MRT = zeros(NS,2*NS);    MRR = zeros(NS,NS);
for i = 1:NS
    for id = 1:2
        MTT(2*(i-1)+id,2*(i-1)+id) = 1/6;                                  %迁移率矩阵A的对角元
    end   
    MRR(i,i) = 0.125;                                                      %迁移率矩阵C的对角元
end                                                                        %构造 M_inf 的对角元

for i = 1:NS
    for j = 1:NS
        if j == i
            continue
        end        
        for id = 1:2
            for jd = 1:2
                MTT(2*(i-1)+id,2*(j-1)+jd) = (XaF(i,j)*ee(i,j,id)*ee(i,j,jd)+YaF(i,j)*(delt(id,jd)-ee(i,j,id)*ee(i,j,jd)))/6;           %迁移率矩阵A的非对角元
            end
        end
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%          
        for jd = 1:2
            MRT(i,2*(j-1)+jd) = 0.25*YbF(i,j)*epsi(i,j,1,jd);                                                                           %迁移率矩阵B的非对角元
        end   
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%          
        MRR(i,j) = 0.125*YcF(i,j);                                                                                                      %迁移率矩阵C的非对角元    
    end
end                                                                        %构造 M_inf 的非对角元
%% 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% 构造矩阵：R_{lubrication}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
RTTexa = zeros(2*NS,2*NS);    RRTexa = zeros(NS,2*NS);    RRRexa = zeros(NS,NS);
for id = 1:2
    for jd = 1:2
        for i = 1:NS
            for j = 1:NS
                if j == i
                    continue
                end
                RTTexa(2*(i-1)+id,2*(i-1)+jd) = RTTexa(2*(i-1)+id,2*(i-1)+jd) + 6*(XA11(i,j)*ee(i,j,id)*ee(i,j,jd)+YA11(i,j)*(delt(id,jd)-ee(i,j,id)*ee(i,j,jd)));      %阻力矩阵A的对角元
            end
        end
    end
end
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
for jd = 1:2
    for i = 1:NS
        for j = 1:NS
            if j == i
                continue
            end
            RRTexa(i,2*(i-1)+jd) = RRTexa(i,2*(i-1)+jd) + 4*YB11(i,j)*epsi(i,j,1,jd);                                                                                   %阻力矩阵B的对角元
        end
    end
end
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
for i = 1:NS
    for j = 1:NS
        if j == i
            continue
        end 
        RRRexa(i,i) = RRRexa(i,i) + 8*YC11(i,j);                                                                                                                       %阻力矩阵C的对角元
    end
end                                                                        %构造矩阵 R_{lubrication} 的对角元
%%
for i = 1:NS
    for j = 1:NS
        if j == i
            continue
        end         
        for id = 1:2
            for jd = 1:2
                RTTexa(2*(i-1)+id,2*(j-1)+jd) = 6*(XA(i,j)*ee(i,j,id)*ee(i,j,jd)+YA(i,j)*(delt(id,jd)-ee(i,j,id)*ee(i,j,jd)));                        %阻力矩阵A的非对角元
            end
        end
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%         
        for jd = 1:2
            RRTexa(i,2*(j-1)+jd) = 4*YB(i,j)*epsi(i,j,1,jd);                                                                                          %阻力矩阵B的非对角元
        end  
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%         
        RRRexa(i,j) = 8*YC(i,j);                                                                                                                      %阻力矩阵C的非对角元        
    end
end                                                                        %构造矩阵 R_{lubrication} 的非对角元
%% 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% 构造全域的迁移率矩阵：R 矩阵和 M 矩阵
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
M_RPY = [MTT,MRT';MRT,MRR];                                                %远场的迁移率矩阵：M_inf
R_lub = [RTTexa,RRTexa';RRTexa,RRRexa];                                    %近场阻力矩阵：R_lub
Rtol = M_RPY*R_lub + eye(3*NS,3*NS);
%Minv_RPY = inv(M_RPY);                                                     %远场迁移率矩阵的逆矩阵：(M_inf)^(-1)：厄米矩阵
%Rtol = R_lub + Minv_RPY;                                                   %全域阻力矩阵
%Mtol = inv(Rtol);                                                          %全域迁移率矩阵
%% 白噪声
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% 给定力矩，计算平移速度和旋转速度
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
F1 = zeros(3*NS,1);
for i = 1:NS
    F1(2*(i-1)+1) = For*D3(i,1);
    F1(2*(i-1)+2) = For*D3(i,2);                              %推进力和白噪声
    F1(2*NS+i) = Tor;                                         %推进力矩和白噪声
end
%U2 = Rtol\F1;
U1 = frac*M_RPY*F1;
[U2,~] = gmres(Rtol,U1,3*NS-1);
%[U2,~] = gmres(Rtol,U1,3*NS-1,1e-9,1);
%%
U = zeros(NS,2);  W = zeros(NS,1);
for i = 1:NS
    U(i,1) = U2(2*(i-1)+1);
    U(i,2) = U2(2*(i-1)+2);                                                %各个活性粒子的平移速度
    W(i,1) = U2(2*NS+i);                                                   %各个活性粒子的旋转速度 
end                                                                                                                                           
%% Runge-Kutta-Methods(龙格库塔法)
%=====================================================================================================================================================================
% Runge-Kutta-Methods(四阶龙格库塔法)：同时用于计算位置和 Material Frame
%=====================================================================================================================================================================
%% 第 1 步：
if mod(kkk,4) == 1
%=====================================================================================================================================================================
% 龙格库塔第1步
%=====================================================================================================================================================================
W1 = W;                                                                    %第1步角速度
K1 = U;                                                                    %第1步平移速度 
W = W1;    U = K1;
%=====================================================================================================================================================================
%Rotation Matrix with Time.
%=====================================================================================================================================================================
theta = zeros(NS,1);        e = zeros(NS,1);         
Rot = zeros(2,2,NS);        tempD3 = zeros(NS,3);
for i = 1:NS
    theta(i) = norm(W1(i,:))*time_h/2; 
    if theta(i) ~= 0
        e(i,1) = W1(i,1)/norm(W1(i,:));
    end    
end    

for i = 1:NS
    if theta(i) == 0
        Rot(1,1,i) = eye(1);
    else    
        Rot(1,1,i) = cos(theta(i));
        Rot(1,2,i) = - sin(theta(i))*e(i,1);
        Rot(2,1,i) = sin(theta(i))*e(i,1);
        Rot(2,2,i) = cos(theta(i));
    end    
end    

for i = 1:NS    
    tempD3(i,1) = Rot(1,1,i)*tempD30(i,1) + Rot(1,2,i)*tempD30(i,2);
    tempD3(i,2) = Rot(2,1,i)*tempD30(i,1) + Rot(2,2,i)*tempD30(i,2); 
end    
%% Material Frame 和位置更新
D3 = tempD3;                                                               %D3
X(:,1:2) = tempX0(:,1:2) + K1(:,1:2)*time_h/2;                             %X1 = X0+h/2*K1
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% 第 2 步：
elseif mod(kkk,4) == 2
%=====================================================================================================================================================================
% 龙格库塔第2步
%=====================================================================================================================================================================
W2 = W;                                                                    %第2步角速度
K2 = U;                                                                    %第2步平移速度
W = W2;    U = K2;
%=====================================================================================================================================================================
%Rotation Matrix with Time.
%=====================================================================================================================================================================
theta = zeros(NS,1);        e = zeros(NS,1);         
Rot = zeros(2,2,NS);        tempD3 = zeros(NS,3);
for i = 1:NS
    theta(i) = norm(W1(i,:))*time_h/2; 
    if theta(i) ~= 0
        e(i,1) = W1(i,1)/norm(W1(i,:));
    end    
end    

for i = 1:NS
    if theta(i) == 0
        Rot(1,1,i) = eye(1);
    else    
        Rot(1,1,i) = cos(theta(i));
        Rot(1,2,i) = - sin(theta(i))*e(i,1);
        Rot(2,1,i) = sin(theta(i))*e(i,1);
        Rot(2,2,i) = cos(theta(i));
    end    
end    

for i = 1:NS    
    tempD3(i,1) = Rot(1,1,i)*tempD30(i,1) + Rot(1,2,i)*tempD30(i,2);
    tempD3(i,2) = Rot(2,1,i)*tempD30(i,1) + Rot(2,2,i)*tempD30(i,2); 
end    
%% Material Frame 和位置更新
D3 = tempD3;                                                               %D3
X(:,1:2)  = tempX0(:,1:2)  + K2(:,1:2) *time_h/2;                          %X2
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% 第 3 步：
elseif mod(kkk,4) == 3
%=====================================================================================================================================================================
% 龙格库塔第3步
%=====================================================================================================================================================================
W3 = W;                                                                    %第3步角速度
K3 = U;                                                                    %第3步平移速度    
W = W3;    U = K3;
%=====================================================================================================================================================================
%Rotation Matrix with Time.
%=====================================================================================================================================================================
theta = zeros(NS,1);        e = zeros(NS,1);         
Rot = zeros(2,2,NS);        tempD3 = zeros(NS,3);
for i = 1:NS
    theta(i) = norm(W1(i,:))*time_h/2; 
    if theta(i) ~= 0
        e(i,1) = W1(i,1)/norm(W1(i,:));
    end    
end    

for i = 1:NS
    if theta(i) == 0
        Rot(1,1,i) = eye(1);
    else    
        Rot(1,1,i) = cos(theta(i));
        Rot(1,2,i) = - sin(theta(i))*e(i,1);
        Rot(2,1,i) = sin(theta(i))*e(i,1);
        Rot(2,2,i) = cos(theta(i));
    end    
end    

for i = 1:NS    
    tempD3(i,1) = Rot(1,1,i)*tempD30(i,1) + Rot(1,2,i)*tempD30(i,2);
    tempD3(i,2) = Rot(2,1,i)*tempD30(i,1) + Rot(2,2,i)*tempD30(i,2); 
end
%% Material Frame 和位置更新
D3 = tempD3;                                                               %D3
X(:,1:2) = tempX0(:,1:2) + K3(:,1:2)*time_h;                               %X3
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% 第 4 步：
elseif mod(kkk,4) == 0  
%=====================================================================================================================================================================
% 龙格库塔实际方向和位置更新
%=====================================================================================================================================================================    
W4 = W;                                                                    %第4步
W5 = (W1 + 2*W2 + 2*W3 + W4)/6;                                            %实际更新角速度
K4 = U;                                                                    %第4步
U5 = (K1 + 2*K2 + 2*K3 + K4)/6;                                            %实际更新平移速度
W = W4;    U = K4;
%=====================================================================================================================================================================
%Rotation Matrix with Time.
%=====================================================================================================================================================================
theta = zeros(NS,1);        e = zeros(NS,1);         
Rot = zeros(2,2,NS);        tempD3 = zeros(NS,3);
for i = 1:NS
    theta(i) = norm(W1(i,:))*time_h/2; 
    if theta(i) ~= 0
        e(i,1) = W1(i,1)/norm(W1(i,:));
    end    
end    

for i = 1:NS
    if theta(i) == 0
        Rot(1,1,i) = eye(1);
    else    
        Rot(1,1,i) = cos(theta(i));
        Rot(1,2,i) = - sin(theta(i))*e(i,1);
        Rot(2,1,i) = sin(theta(i))*e(i,1);
        Rot(2,2,i) = cos(theta(i));
    end    
end    

for i = 1:NS    
    tempD3(i,1) = Rot(1,1,i)*tempD30(i,1) + Rot(1,2,i)*tempD30(i,2);
    tempD3(i,2) = Rot(2,1,i)*tempD30(i,1) + Rot(2,2,i)*tempD30(i,2); 
end
%% Material Frame 和位置更新
D3 = tempD3;                                                               %D3(实际方向)
tempD30 = D3;                                                              %D30(实际方向)
X(:,1:2) = tempX0(:,1:2) + time_h*U5(:,1:2);                               %X(实际的构象)
tempX0 = X;                                                                %X0(实际的构象)
times = times + time_h;                                                    %时间更新
end
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% 
%=====================================================================================================================================================================
% 球心位置和 Material Frame 的数据输出
%=====================================================================================================================================================================  
for i = 1:NS   
    fprintf(fid1,'%d\t',kkk);                fprintf(fid1,'%d\n',i);   
    fprintf(fid1,'%18.14f\t',X(i,1));         fprintf(fid1,'%18.14f\n',X(i,2));
end                                                                        %构象 

for i = 1:NS 
    fprintf(fid2,'%d\t',kkk);                fprintf(fid2,'%d\n',i);  
    fprintf(fid2,'%18.14f\t',D3(i,1));        fprintf(fid2,'%18.14f\n',D3(i,2));    
end                                                                        %Material Frame

for i = 1:NS
    fprintf(fid3,'%d\t',kkk);                fprintf(fid3,'%d\n',i); 
    fprintf(fid3,'%18.14f\t',U(i,1));         fprintf(fid3,'%18.14f\n',U(i,2));  %每个球的平移速度
end

for i = 1:NS
    fprintf(fid4,'%d\t',kkk);                fprintf(fid4,'%d\n',i); 
    fprintf(fid4,'%18.14f\n',W(i,1));                                      %每个球的角速度
end 
%%
if mod(kkk,4) == 0  
for i = 1:NS
    fprintf(fid3,'%d\t',kkk);                fprintf(fid3,'%d\n',i); 
    fprintf(fid3,'%18.14f\t',U5(i,1));        fprintf(fid3,'%18.14f\n',U5(i,2));  %每个球的平移速度
end

for i = 1:NS
    fprintf(fid4,'%d\t',kkk);                fprintf(fid4,'%d\n',i); 
    fprintf(fid4,'%18.14f\n',W5(i,1));                                      %每个球的角速度
end     
disp(kkk);
end    
     
%%
end                                                                        %结束总循环
fclose(fid1);    fclose(fid2);    fclose(fid3);  
fclose(fid4);    
%close(vidObj1);




















